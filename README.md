# Algorithm-Exercises

A place to restore my code for Algorithm


## 25-9-16

### 排序算法

#### 选择排序

- 时间复杂度
  _O(n^2)_
- 空间复杂度
  _O(1)_
- 非稳定性排序
  如{4,4,2,3,1}第一次选择交换后 4 的相对顺序改变

#### 冒泡排序

- 时间复杂度
  平均时间复杂度 _O(n^2)_,优化后最佳时间复杂度为 _O(n)_
- 空间复杂度
  _O(1)_
- 稳定排序
- 优化
  如果一轮冒泡没有交换元素，则直接退出循环，排序完成。

#### 插入排序

- 时间复杂度
  平均时间复杂度为 _O(n^2)_,最佳时间复杂度 _O(n)_
- 空间复杂度
  _O(1)_
- 稳定排序
- 自适应性
  当数据有序时，插入操作停止，最佳时间复杂度 _O(n)_

#### 快速排序

- 时间复杂度
  平均时间复杂度 _O(nlogn)_
- 空间复杂度
  _O(n)_,完全倒序时递归深度为 n
- 就地排序
- 非稳定性
  哨兵划分最后交换基准时可能交换相同元素的位置
- 优化
  - 基准数优化
    取最左边、最右边和中间三个数的最小值作为基准数，可以降低划分为 _0_ 和 _n-1_ 两个子数组的概率
  - 递归深度优化
    每次递归长度更小的子数组，由于子数组的长度不会超过 _n/2_,所以递归深度不会超过 _logn_,从而将最差空间复杂度优化为 _O(logn)_
- 注意

```C++
int partition(vector<int> &nums, int left, int right)
{
    int i = left, j = right;
    while (i < j)
    {
        //i和j的移动顺序不能变，和基准的选择有关
        while (i < j && nums[j] >= nums[left])
            j--;
        while (i < j && nums[i] <= nums[left])
            i++;
        swap(nums[i], nums[j]);
    }
    swap(nums[left], nums[i]);
    return i;
}
```

在快速排序的“哨兵划分”中，i 和 j 的移动顺序不能随意变换，和基准的选取有关
比如在选择左边第一个元素为基准后，j 要先移动，即先找到第一个小于基准的元素
这样的话最好循环结束时是 j 移动到 i 上，而 i 是小于或等于基准的元素的索引，所以和基准元素交换后满足划分要求；
而如果先找第一个大于基准的元素，最后是 i 移动到 j 上，是一个大于或等于基准的元素，交换后，如果左边第一个元素大于基准元素，不满足划分要求。
