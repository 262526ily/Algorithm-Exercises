# Algorithm-Exercises

A place to restore my code for Algorithm

## **易错集**

- 尾后迭代器（_past-the-end iterator_）
  尾后迭代器不指向容器内的任何元素，指向的是容器中最后一个元素后面的位置，在使用需要其作为函数参数时应该选择指向所需最后一个元素的位置的迭代器

## **心得**

- 在处理数组中的一部分连续元素时，定义的函数形参应该包括总数组的引用和部分数组的 _size_；

## 25-9-16

### 排序算法

#### 选择排序

- 时间复杂度
  _O(n^2)_
- 空间复杂度
  _O(1)_
- 非稳定性排序
  如{4,4,2,3,1}第一次选择交换后 4 的相对顺序改变

#### 冒泡排序

- 时间复杂度
  平均时间复杂度 _O(n^2)_,优化后最佳时间复杂度为 _O(n)_
- 空间复杂度
  _O(1)_
- 稳定排序
- 优化
  如果一轮冒泡没有交换元素，则直接退出循环，排序完成。

#### 插入排序

- 时间复杂度
  平均时间复杂度为 _O(n^2)_,最佳时间复杂度 _O(n)_
- 空间复杂度
  _O(1)_
- 稳定排序
- 自适应性
  当数据有序时，插入操作停止，最佳时间复杂度 _O(n)_

#### 快速排序

- 时间复杂度
  平均时间复杂度 _O(nlogn)_
- 空间复杂度
  _O(n)_,完全倒序时递归深度为 _n_
- 就地排序
- 非稳定性
  哨兵划分最后交换基准时可能交换相同元素的位置
- 优化
  - 基准数优化
    取最左边、最右边和中间三个数的最小值作为基准数，可以降低划分为 _0_ 和 _n-1_ 两个子数组的概率
  - 递归深度优化
    每次递归长度更小的子数组，由于子数组的长度不会超过 _n/2_,所以递归深度不会超过 _logn_,从而将最差空间复杂度优化为 _O(logn)_
- 注意

```C++
int partition(vector<int> &nums, int left, int right)
{
    int i = left, j = right;
    while (i < j)
    {
        //i和j的移动顺序不能变，和基准的选择有关
        while (i < j && nums[j] >= nums[left])
            j--;
        while (i < j && nums[i] <= nums[left])
            i++;
        swap(nums[i], nums[j]);
    }
    swap(nums[left], nums[i]);
    return i;
}
```

在快速排序的“哨兵划分”中，i 和 j 的移动顺序不能随意变换，和基准的选取有关
比如在选择左边第一个元素为基准后，j 要先移动，即先找到第一个小于基准的元素
这样的话最好循环结束时是 j 移动到 i 上，而 i 是小于或等于基准的元素的索引，所以和基准元素交换后满足划分要求；
而如果先找第一个大于基准的元素，最后是 i 移动到 j 上，是一个大于或等于基准的元素，交换后，如果左边第一个元素大于基准元素，不满足划分要求。

## 25-9-17

### 堆(heap)

#### 堆的常用操作

- 堆是一种特殊的完全二叉树
  - 大顶堆：子节点<=当前结点
  - 小顶堆：子节点>=当前结点
- 常用操作
  |函数|描述|时间复杂度|
  |-------|-------|-------|
  |push() |元素入堆|_O(logn)_|
  |pop() |堆顶元素出堆|_O(logn)_|
  |peek() |获取堆顶元素|_O(1)_|
  |isEmpty()|返回堆是否为空|_O(1)_|
  |size() |获取堆元素的数量|_O(1)_|

#### 建堆操作

- 使用入堆操作建堆
  执行了 _n_ 次入堆操作，时间复杂度为 _O(nlogn)_
- 通过遍历堆化建堆
  通过倒序地自上而下堆化非叶子结点建堆，可以将时间复杂度优化至 _O(n)_

#### top-k 问题

- 给定一个数组，依次输出里面的 k 个最大值
- 通过遍历求解
  时间复杂度为 _O(nk)_,当 k 趋近于 n 时，该算法的时间复杂度退化至 _O(n^2)_
- 先排序在输出最右端的 k 个元素
  时间复杂度为 _O(nlogn)_
- 使用堆来求解
  - 解法
    让前 k 个元素入堆（小顶堆），然后从第 k+1 个元素开始，和堆顶元素比较，大于堆顶元素则弹出堆顶元素，让该元素入堆，否则换下一个元素，结束时，堆里的元素即为目标元素。
  - 时间复杂度为 _O(nlogk)_
    当 k 越小，时间复杂度趋近于 _O(n)_
